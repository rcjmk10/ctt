# Central Authorization Server with Token Forwarding Example

Here's a comprehensive example of implementing Option 2, where you have a central authorization service that handles OAuth2 flows and forwards tokens to client applications.

## Architecture Overview

1. **Central Auth Service**: Handles OAuth2 login with providers
2. **Client Applications**: Redirect to central auth service, receive tokens
3. **Token Forwarding**: Auth service forwards tokens to clients after authentication

## 1. Central Authorization Service Implementation

### Dependencies (pom.xml)
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
```

### Application Configuration
```java
@SpringBootApplication
public class AuthServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthServiceApplication.class, args);
    }
}
```

### Security Configuration
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/", "/login**", "/oauth2/**").permitAll()
                .anyRequest().authenticated()
            .and()
            .oauth2Login()
                .authorizationEndpoint()
                    .baseUri("/oauth2/authorize")
                    .authorizationRequestRepository(cookieAuthorizationRequestRepository())
                .and()
                .redirectionEndpoint()
                    .baseUri("/oauth2/callback/*")
                .and()
                .successHandler(oAuth2SuccessHandler());
    }

    @Bean
    public OAuth2SuccessHandler oAuth2SuccessHandler() {
        return new OAuth2SuccessHandler();
    }

    @Bean
    public AuthorizationRequestRepository<OAuth2AuthorizationRequest> cookieAuthorizationRequestRepository() {
        return new HttpCookieOAuth2AuthorizationRequestRepository();
    }
}
```

### OAuth2 Success Handler (Token Forwarding)
```java
@Component
public class OAuth2SuccessHandler extends SimpleUrlAuthenticationSuccessHandler {

    @Value("${allowed.redirect.domains}")
    private List<String> allowedRedirectDomains;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, 
                                       HttpServletResponse response, 
                                       Authentication authentication) throws IOException {
        
        String targetUrl = determineTargetUrl(request, authentication);
        
        if (response.isCommitted()) {
            logger.debug("Response has already been committed. Unable to redirect to " + targetUrl);
            return;
        }
        
        // Forward tokens to the client application
        String redirectUrl = request.getParameter("redirect_uri");
        if (isAllowedRedirect(redirectUrl)) {
            OAuth2AuthenticationToken authToken = (OAuth2AuthenticationToken) authentication;
            OAuth2AuthorizedClient client = authorizedClientService.loadAuthorizedClient(
                authToken.getAuthorizedClientRegistrationId(), 
                authToken.getName());
            
            String tokenForwardUrl = buildTokenForwardUrl(redirectUrl, client);
            getRedirectStrategy().sendRedirect(request, response, tokenForwardUrl);
        } else {
            throw new IllegalStateException("Invalid redirect URL");
        }
    }

    private String buildTokenForwardUrl(String baseUrl, OAuth2AuthorizedClient client) {
        UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(baseUrl)
            .queryParam("access_token", client.getAccessToken().getTokenValue());
            
        if (client.getRefreshToken() != null) {
            builder.queryParam("refresh_token", client.getRefreshToken().getTokenValue());
        }
        
        return builder.build().toUriString();
    }

    private boolean isAllowedRedirect(String url) {
        if (url == null) return false;
        
        try {
            URI uri = new URI(url);
            String host = uri.getHost();
            return allowedRedirectDomains.stream().anyMatch(domain -> host.endsWith(domain));
        } catch (URISyntaxException e) {
            return false;
        }
    }
}
```

## 2. Client Application Implementation

### Client Security Configuration
```java
@Configuration
@EnableWebSecurity
public class ClientSecurityConfig extends WebSecurityConfigurerAdapter {

    @Value("${auth.service.url}")
    private String authServiceUrl;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/", "/login**", "/auth/callback").permitAll()
                .anyRequest().authenticated()
            .and()
            .oauth2Client()
            .and()
            .addFilterBefore(new TokenValidationFilter(), BasicAuthenticationFilter.class);
    }

    @Bean
    public OAuth2AuthorizedClientService authorizedClientService() {
        return new InMemoryOAuth2AuthorizedClientService();
    }

    @Bean
    public WebClient webClient(OAuth2AuthorizedClientService clientService) {
        ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2 = 
            new ServletOAuth2AuthorizedClientExchangeFilterFunction(clientService);
        return WebClient.builder()
            .apply(oauth2.oauth2Configuration())
            .build();
    }
}
```

### Token Validation Filter
```java
public class TokenValidationFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        if (request.getRequestURI().startsWith("/auth/callback")) {
            String accessToken = request.getParameter("access_token");
            // Validate token (could call auth service or validate locally)
            if (isValidToken(accessToken)) {
                // Store token in session or security context
                SecurityContextHolder.getContext().setAuthentication(
                    new PreAuthenticatedAuthenticationToken(accessToken, null));
            } else {
                response.sendError(HttpStatus.UNAUTHORIZED.value());
                return;
            }
        }
        
        filterChain.doFilter(request, response);
    }

    private boolean isValidToken(String token) {
        // Implement token validation logic
        return token != null && !token.isEmpty();
    }
}
```

## 3. Flow Explanation

1. **Client initiates login**:
   ```html
   <a href="https://auth-service.example.com/oauth2/authorize/google?redirect_uri=https://client1.example.com/auth/callback">
     Login with Google
   </a>
   ```

2. **Auth service handles OAuth2 flow** with the provider (Google in this case)

3. **After successful authentication**, the auth service:
   - Receives tokens from the provider
   - Validates and processes them
   - Redirects back to the client with tokens in URL parameters

4. **Client application**:
   - Receives tokens at the callback endpoint
   - Validates them (either locally or by calling auth service)
   - Establishes a session

## 4. Additional Considerations

### Token Security
- Use PKCE (Proof Key for Code Exchange) for public clients
- Consider using short-lived access tokens with refresh tokens
- Implement proper token validation in the client

### Configuration
```yaml
# Auth service application.yml
allowed:
  redirect:
    domains:
      - example.com
      - client1.com
      - client2.org

# Client application.yml
auth:
  service:
    url: https://auth-service.example.com
```

### Cross-Origin Considerations
If your clients are SPAs, you might need to:
- Use postMessage instead of redirects for token forwarding
- Implement proper CORS configuration
- Consider the OAuth2 implicit flow (though not recommended for new apps)

This architecture provides a centralized way to manage authentication while allowing multiple client applications to benefit from a single OAuth2 registration with providers.


---open AI

Yes! Here's a complete outline and code sample for **Option 2: Central OAuth2 Proxy Gateway**, where only **one app handles the OAuth2 login** (like `auth.example.com`) and **forwards the token/session** to multiple other client apps (`site1.example.com`, `site2.example.com`).

---

## üéØ Scenario

- You have a **central login server**: `auth.example.com`
- Multiple frontend web clients: `site1.example.com`, `site2.example.com`
- Only `auth.example.com` handles the OAuth2 login flow
- After login, it issues a **signed JWT** or session token
- Client apps **receive and validate the token**

---

## üõ†Ô∏è Components

### ‚úÖ `auth.example.com` (Spring Boot app)
- Has OAuth2 login (e.g., Google, Okta, custom)
- After login, issues JWT token and **redirects with token or sets shared cookie**

### ‚úÖ `site1.example.com`, `site2.example.com` (Spring Boot clients)
- No OAuth2 login config
- Read and validate JWT token (via cookie or redirect param)
- Authenticated locally using token

---

## üîí JWT Token Sharing ‚Äì Approaches
- **üîÅ Redirect + Token Param:** Send JWT as a URL parameter on redirect (`?token=...`)
- **üç™ Cookie-based:** Set a shared cookie (`Domain=.example.com`)
- **üì¶ Header forwarding:** For internal APIs or AJAX use

We‚Äôll demo both **redirect + token param** and **cookie** below.

---

## üîß 1. `auth.example.com` Configuration

### `application.yml`:

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: YOUR_CLIENT_ID
            client-secret: YOUR_CLIENT_SECRET
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
            scope: openid, profile, email
        provider:
          google:
            authorization-uri: https://accounts.google.com/o/oauth2/v2/auth
            token-uri: https://oauth2.googleapis.com/token
            user-info-uri: https://www.googleapis.com/oauth2/v3/userinfo
            user-name-attribute: sub
```

---

### Custom Success Handler

```java
@Component
public class OAuth2LoginSuccessHandler extends SimpleUrlAuthenticationSuccessHandler {

    private final JwtService jwtService;

    public OAuth2LoginSuccessHandler(JwtService jwtService) {
        this.jwtService = jwtService;
    }

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request,
                                        HttpServletResponse response,
                                        Authentication authentication)
            throws IOException, ServletException {

        String jwt = jwtService.generateToken(authentication);

        // Option 1: Send via redirect param
        String target = request.getParameter("redirect_uri"); // passed in login request
        if (target != null && !target.isBlank()) {
            getRedirectStrategy().sendRedirect(request, response, target + "?token=" + jwt);
        } else {
            response.getWriter().write("Login success, no redirect_uri specified.");
        }
    }
}
```

---

### Security Config

```java
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain security(HttpSecurity http, OAuth2LoginSuccessHandler successHandler) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
            .oauth2Login(oauth -> oauth.successHandler(successHandler));
        return http.build();
    }
}
```

---

### JWT Service (same as Option 3)

```java
@Component
public class JwtService {
    private final Key key = Keys.secretKeyFor(SignatureAlgorithm.HS256);

    public String generateToken(Authentication auth) {
        return Jwts.builder()
                .setSubject(auth.getName())
                .claim("authorities", auth.getAuthorities())
                .setIssuedAt(new Date())
                .setExpiration(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))
                .signWith(key)
                .compact();
    }

    public Authentication parseToken(String token) {
        try {
            Claims claims = Jwts.parserBuilder().setSigningKey(key).build()
                    .parseClaimsJws(token).getBody();
            String username = claims.getSubject();
            List<GrantedAuthority> authorities = ((List<?>) claims.get("authorities")).stream()
                    .map(auth -> new SimpleGrantedAuthority(auth.toString()))
                    .toList();
            return new UsernamePasswordAuthenticationToken(username, null, authorities);
        } catch (Exception e) {
            return null;
        }
    }
}
```

---

## üîß 2. `site1.example.com` ‚Äì Trust JWT from Gateway

This app has no OAuth2 config ‚Äî it just **accepts the JWT token** (from query param or cookie) and authenticates users.

### JWT Auth Filter

```java
@Component
public class JwtAuthFilter extends OncePerRequestFilter {

    @Autowired
    JwtService jwtService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        String token = request.getParameter("token"); // or from cookie/header

        if (token != null) {
            Authentication auth = jwtService.parseToken(token);
            if (auth != null) {
                SecurityContextHolder.getContext().setAuthentication(auth);
            }
        }

        filterChain.doFilter(request, response);
    }
}
```

---

### Security Config for `site1`

```java
@Configuration
public class SecurityConfig {

    @Autowired
    JwtAuthFilter jwtAuthFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .anyRequest().authenticated())
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
```

---

### üí° Redirect Example Flow

1. User goes to `site1.example.com/dashboard`
2. If not authenticated, redirect to:
   ```
   https://auth.example.com/oauth2/authorization/google?redirect_uri=https://site1.example.com/auth/callback
   ```
3. After login, Spring redirects to:
   ```
   https://site1.example.com/auth/callback?token=eyJhbGciOiJI...
   ```
4. `site1` reads token from param, authenticates the user

---

## ‚úÖ Optional: Token Relay via Cookie

If you're using shared subdomains (e.g., `.example.com`), you can **set a shared cookie** from `auth.example.com`, and the clients (`site1`, `site2`) can read it like in Option 3.

Use:

```java
ResponseCookie cookie = ResponseCookie.from("AUTH_TOKEN", jwt)
    .domain(".example.com")
    .path("/")
    .secure(true)
    .httpOnly(true)
    .sameSite("Lax")
    .build();
response.addHeader(HttpHeaders.SET_COOKIE, cookie.toString());
```

Then the clients just pull the token from `request.getCookies()` instead of `request.getParameter("token")`.

---

Would you like a working GitHub sample or starter project for this?

-----------------------------------openAI2
Yes! Here‚Äôs a simple **Spring Boot-based implementation** of **Option 1: SSO via OAuth2 Proxy Login**, where:

- **Site1** redirects to **Auth Site** to initiate login.
- **Auth Site** authenticates with the OAuth server (`wam.company.com`).
- After successful login, **Auth Site redirects back to Site1** with a **signed JWT**.
- **Site1 verifies the token** and creates a local session.

---

### üîß Assumptions
- You‚Äôre using **Spring Boot + Spring Security + OAuth2 Client**.
- **JWT** is used as the token format between Auth Site and Site1.
- A **shared secret** or **public key infrastructure** exists between Site1 and Auth Site.

---

## ‚úÖ 1. **Auth Site** ‚Äî Initiate OAuth2 Login & Return Token

### `application.yml` (OAuth2 Client Setup)
```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          wam:
            client-id: your-client-id
            client-secret: your-secret
            scope: openid, profile, email
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
            authorization-grant-type: authorization_code
            client-name: WAM
        provider:
          wam:
            issuer-uri: https://wam.company.com
```

### Auth Controller ‚Äî `/loginProxy`
```java
@RestController
@RequestMapping("/proxy")
public class ProxyLoginController {

    @GetMapping("/login")
    public ResponseEntity<Void> proxyLogin(HttpServletRequest request) {
        String redirectUri = request.getParameter("redirect_uri");
        request.getSession().setAttribute("redirect_uri", redirectUri);
        URI uri = URI.create("/oauth2/authorization/wam"); // this triggers Spring Security's login
        HttpHeaders headers = new HttpHeaders();
        headers.setLocation(uri);
        return new ResponseEntity<>(headers, HttpStatus.FOUND);
    }

    @GetMapping("/callback")
    public ResponseEntity<Void> handleCallback(Authentication authentication, HttpServletRequest request) {
        OidcUser oidcUser = (OidcUser) authentication.getPrincipal();
        
        // Generate signed JWT (can use Nimbus JOSE + JWT or jjwt)
        String jwt = JwtUtils.generateToken(oidcUser); // implement this

        String redirectUri = (String) request.getSession().getAttribute("redirect_uri");
        URI uri = URI.create(redirectUri + "?token=" + jwt);

        HttpHeaders headers = new HttpHeaders();
        headers.setLocation(uri);
        return new ResponseEntity<>(headers, HttpStatus.FOUND);
    }
}
```

> üîê **Token Generation** can use `io.jsonwebtoken` or `nimbus-jose-jwt`.

---

## ‚úÖ 2. **Site1** ‚Äî Accept Token & Authenticate Locally

### `application.yml`
No need for OAuth2 config unless you plan to directly integrate with `wam.company.com`.

### `TokenAuthenticationFilter.java`
```java
public class TokenAuthenticationFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
        throws ServletException, IOException {

        String token = request.getParameter("token");
        if (token != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            try {
                Claims claims = JwtUtils.parseToken(token); // validate signature, expiry, etc.
                String username = claims.getSubject();

                List<GrantedAuthority> authorities = List.of(new SimpleGrantedAuthority("ROLE_USER"));
                UsernamePasswordAuthenticationToken auth =
                        new UsernamePasswordAuthenticationToken(username, null, authorities);
                SecurityContextHolder.getContext().setAuthentication(auth);
            } catch (JwtException e) {
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                return;
            }
        }
        filterChain.doFilter(request, response);
    }
}
```

### Register Filter
```java
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .addFilterBefore(new TokenAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            );
        return http.build();
    }
}
```

---

## ‚úÖ 3. **JWT Utility (Shared by Both Apps)**

### `JwtUtils.java`
```java
public class JwtUtils {
    private static final String SECRET = "your-shared-secret"; // Store securely

    public static String generateToken(OidcUser user) {
        return Jwts.builder()
                .setSubject(user.getEmail())
                .claim("name", user.getFullName())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 5 * 60 * 1000))
                .signWith(SignatureAlgorithm.HS256, SECRET)
                .compact();
    }

    public static Claims parseToken(String token) {
        return Jwts.parser()
                .setSigningKey(SECRET)
                .parseClaimsJws(token)
                .getBody();
    }
}
```

---

### üß™ Flow Test Summary

| Step | Action |
|------|--------|
| 1 | Site1 redirects to `https://clientappt.company.com/proxy/login?redirect_uri=https://site1.clientappt.company.com/callback` |
| 2 | Auth Site authenticates via WAM |
| 3 | Auth Site generates JWT and redirects back to Site1 with token |
| 4 | Site1 reads token, verifies it, logs in user |

---

Want me to package this into two minimal Spring Boot starter projects (`site1` and `auth-site`) for local testing?



Yes ‚Äî if you‚Äôre using a **self-signed SSL certificate** and getting SSL errors with `RestTemplate`, you can configure a custom `RestTemplate` bean that **trusts self-signed certificates**.

Here‚Äôs a clean solution using a custom class that builds a `RestTemplate` that **ignores SSL certificate errors**. This is often used **in dev/test environments** ‚Äî never use this in production unless you explicitly manage security.

---

### ‚úÖ Custom `RestTemplate` that Trusts Self-Signed SSL

```java
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

import javax.net.ssl.*;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;

import org.apache.http.conn.ssl.NoopHostnameVerifier;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

public class UnsafeRestTemplateFactory {

    public static RestTemplate create() throws Exception {
        // Trust manager that ignores certificate validation
        TrustManager[] trustAllCerts = new TrustManager[]{
            new X509TrustManager() {
                public void checkClientTrusted(X509Certificate[] xcs, String string) {}
                public void checkServerTrusted(X509Certificate[] xcs, String string) {}
                public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }
            }
        };

        // Set up SSL context
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(null, trustAllCerts, new SecureRandom());

        // Create socket factory with Noop HostnameVerifier to ignore hostname mismatch
        SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory(
                sslContext, NoopHostnameVerifier.INSTANCE);

        CloseableHttpClient httpClient = HttpClients.custom()
                .setSSLSocketFactory(socketFactory)
                .build();

        HttpComponentsClientHttpRequestFactory factory =
                new HttpComponentsClientHttpRequestFactory(httpClient);

        return new RestTemplate(factory);
    }
}
```

---

### üß™ Example Usage

```java
@RestController
public class TestController {

    @GetMapping("/test-ssl")
    public String testSSL() throws Exception {
        RestTemplate restTemplate = UnsafeRestTemplateFactory.create();
        String response = restTemplate.getForObject("https://your-self-signed-site.local", String.class);
        return response;
    }
}
```

---

### ‚ö†Ô∏è Important Notes

- This completely **disables SSL certificate validation and hostname verification**. Only use this in:
  - **Internal tools**
  - **Local development**
  - **Testing against mock services**
- If you're in **production**, it's better to:
  - Import your self-signed cert into a truststore.
  - Configure SSL context with proper keystore/truststore.

---

Would you like a version that loads a **custom truststore with your self-signed cert** instead (safer than fully skipping checks)?


Yes ‚Äî in **Spring Boot**, you can **conditionally apply filters** based on URL patterns using one of the following approaches:

---

## ‚úÖ Option 1: Configure Filters Manually via `FilterRegistrationBean`

This gives you full control over which URLs each filter applies to.

### Example Setup:

```java
@Configuration
public class FilterConfig {

    @Bean
    public FilterRegistrationBean<LoadingUserFilter> userFilter() {
        FilterRegistrationBean<LoadingUserFilter> registrationBean = new FilterRegistrationBean<>();
        registrationBean.setFilter(new LoadingUserFilter());
        registrationBean.addUrlPatterns("/secure/*"); // Not applied to /public
        registrationBean.setOrder(1);
        return registrationBean;
    }

    @Bean
    public FilterRegistrationBean<CheckingAddressFilter> addressFilter() {
        FilterRegistrationBean<CheckingAddressFilter> registrationBean = new FilterRegistrationBean<>();
        registrationBean.setFilter(new CheckingAddressFilter());
        registrationBean.addUrlPatterns("/secure/*", "/office/*");
        registrationBean.setOrder(2);
        return registrationBean;
    }

    @Bean
    public FilterRegistrationBean<OfficeFunctionFilter> officeFilter() {
        FilterRegistrationBean<OfficeFunctionFilter> registrationBean = new FilterRegistrationBean<>();
        registrationBean.setFilter(new OfficeFunctionFilter());
        registrationBean.addUrlPatterns("/office/*"); // Only applies to office
        registrationBean.setOrder(3);
        return registrationBean;
    }
}
```

---

## ‚úÖ Option 2: Inside the Filter Itself (Path-Based Logic)

If you want to register a filter globally but have internal logic to skip paths:

```java
public class LoadingUserFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
        throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;
        String path = req.getRequestURI();

        if (path.startsWith("/public")) {
            chain.doFilter(request, response); // Skip filter
            return;
        }

        // Execute filter logic
        // ...
        chain.doFilter(request, response);
    }
}
```

---

## ‚úÖ Option 3: Use `OncePerRequestFilter` + `AntPathMatcher` for More Complex Rules

```java
public class ConditionalFilter extends OncePerRequestFilter {
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {

        String path = request.getRequestURI();
        if (pathMatcher.match("/public/**", path)) {
            filterChain.doFilter(request, response); // skip
            return;
        }

        // Otherwise do the filter logic
        filterChain.doFilter(request, response);
    }
}
```

---

### Summary of What You Asked:

| URL Path        | Filters Applied                     |
|----------------|--------------------------------------|
| `/public/**`    | ‚ùå `LoadingUserFilter`, `CheckingAddressFilter` |
| `/office/**`    | ‚úÖ `OfficeFunctionFilter`           |
| `/secure/**`    | ‚úÖ All relevant filters             |

Use `FilterRegistrationBean` if you want the cleanest and most declarative control.

Let me know if you'd like me to generate a full sample Spring Boot class set for your filters.
Yes ‚Äî the issue you're encountering is common when trying to make one Spring Boot app (Site1) piggyback on another (Auth Site) that is already integrated with an OAuth server.

Let‚Äôs walk through how to implement **Option 1: SSO via OAuth2 Proxy Login**, and how to solve the **filter interference issue**.

---

## ‚úÖ Goal Recap

- `site1.clientappt.company.com`: Needs to **SSO via `clientappt.company.com`** (Auth Site)
- `clientappt.company.com`: Spring Boot app, registered with OAuth2 provider `wam.company.com`
- Want to avoid OAuth registration on Site1; let Auth Site act as a secure SSO proxy.

---

## ‚úÖ Recommended Setup

### üèÅ High-Level Strategy

1. **User opens Site1** (unauthenticated)
2. Site1 **redirects to Auth Site** ‚Üí `/sso/proxy-login?redirect=https://site1...`
3. Auth Site checks WAM token via `officerContextFilter`
4. If not authenticated:
   - Redirects to WAM
   - Logs in, extracts `officerId`
5. After successful auth:
   - Auth Site issues **signed JWT** (or session token) to Site1
6. Site1 receives token ‚Üí validates signature ‚Üí establishes session

---

## üîê SSO Proxy Endpoint on Auth Site

```java
@GetMapping("/sso/proxy-login")
public void proxyLogin(HttpServletRequest request, HttpServletResponse response,
                       @RequestParam String redirect) throws IOException {
    Officer officer = officerContext.getOfficer(); // Retrieved via officerContextFilter

    if (officer == null) {
        // This will trigger the officerContextFilter to redirect to WAM
        response.sendRedirect("/login?redirect=" + URLEncoder.encode(redirect, "UTF-8"));
        return;
    }

    String jwt = jwtService.createToken(officer); // Sign and encode officer ID, roles, etc.
    String redirectWithToken = redirect + "?token=" + jwt;
    response.sendRedirect(redirectWithToken);
}
```

---

## üõ°Ô∏è Token Validation on Site1

- Site1 must **trust the JWT** signed by Auth Site
- Ideally use **shared secret or public/private keys**

```java
@Bean
public SecurityFilterChain security(HttpSecurity http) throws Exception {
    http
      .authorizeHttpRequests(authz -> authz
          .requestMatchers("/public/**").permitAll()
          .anyRequest().authenticated()
      )
      .addFilterBefore(new JwtAuthFilter(jwtService), UsernamePasswordAuthenticationFilter.class);
    return http.build();
}
```

---

## üö´ Solving Filter Conflicts

On **Auth Site**, your `officerContextFilter` and others likely block:

- `/sso/proxy-login` from working cleanly
- Auth Site from **redirecting back to Site1** (because filters interrupt before redirect)

### ‚úÖ Fix: Bypass Filters for Proxy Endpoint

Update your filters like this:

```java
@Override
public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
        throws IOException, ServletException {

    HttpServletRequest request = (HttpServletRequest) req;
    String path = request.getRequestURI();

    if (path.startsWith("/sso/proxy-login") || path.startsWith("/public")) {
        chain.doFilter(req, res); // Skip filter
        return;
    }

    // Otherwise do filter logic
    ...
}
```

Or use `FilterRegistrationBean` and exclude path like:

```java
@Bean
public FilterRegistrationBean<OfficerContextFilter> officerFilter() {
    FilterRegistrationBean<OfficerContextFilter> reg = new FilterRegistrationBean<>();
    reg.setFilter(new OfficerContextFilter());
    reg.addUrlPatterns("/*");
    reg.setName("officerFilter");
    reg.setOrder(1);
    reg.addInitParameter("exclusions", "/sso/proxy-login,/public/*");
    return reg;
}
```

---

## üîê Token Creation Example (JWT)

```java
public String createToken(Officer officer) {
    return Jwts.builder()
        .setSubject(officer.getId())
        .claim("role", officer.getRole())
        .setIssuedAt(new Date())
        .setExpiration(new Date(System.currentTimeMillis() + 86400000))
        .signWith(SignatureAlgorithm.HS512, secretKey)
        .compact();
}
```

---

## üöÄ Summary

| Component | Action |
|----------|--------|
| **Site1** | Redirect to Auth Site `/sso/proxy-login?redirect=...` |
| **Auth Site** | Validates user via WAM, returns signed token to Site1 |
| **Site1** | Parses and trusts token, logs in user |
| **Filters** | Skip on `/sso/proxy-login` to avoid interference |
| **Security** | Use JWT + shared secret or PKI |

---

Would you like a complete working **Spring Boot mini project** with both Site1 and Auth Site configured for this? I can scaffold that next.



Yes! In **Spring Boot 3.2.12** with **Spring Security 6**, if you're implementing an **OAuth2 client** and the **client authentication method is POST** (i.e., `client_secret_post`), you can customize the security configuration to support this.

Here‚Äôs a **sample `SecurityConfig`** and associated setup:

---

### ‚úÖ 1. **Spring Security Configuration (Java Config)**

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authorize -> authorize
                .requestMatchers("/login", "/oauth2/**").permitAll()
                .anyRequest().authenticated()
            )
            .oauth2Login(Customizer.withDefaults()) // enables oauth2Login with default config
            .oauth2Client(Customizer.withDefaults()); // enables OAuth2 client support

        return http.build();
    }
}
```

---

### ‚úÖ 2. **Configure `client-authentication-method` to POST in application.yml / properties**

Use the `spring.security.oauth2.client.registration` block:

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          my-client:
            client-id: your-client-id
            client-secret: your-client-secret
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
            scope: openid, profile, email
        provider:
          my-client-provider:
            authorization-uri: https://provider.com/oauth2/authorize
            token-uri: https://provider.com/oauth2/token
            user-info-uri: https://provider.com/userinfo
            user-name-attribute: sub
```

---

### ‚úÖ 3. **Override `OAuth2AccessTokenResponseClient` to send POST for client authentication**

Spring Security uses **`BasicAuthenticationConverter`** by default for `client_secret_basic`. To switch to `client_secret_post`, override the token response client like this:

```java
@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
        ClientRegistrationRepository clientRegistrationRepository,
        OAuth2AuthorizedClientRepository authorizedClientRepository) {

    OAuth2AuthorizedClientProvider authorizedClientProvider =
            OAuth2AuthorizedClientProviderBuilder.builder()
                    .authorizationCode()
                    .refreshToken()
                    .clientCredentials()
                    .build();

    DefaultOAuth2AuthorizedClientManager authorizedClientManager =
            new DefaultOAuth2AuthorizedClientManager(
                    clientRegistrationRepository, authorizedClientRepository);

    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

    // Custom token response client with client_secret_post
    authorizedClientManager.setAccessTokenResponseClient(authorizationCodeTokenResponseClient());

    return authorizedClientManager;
}

private OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> authorizationCodeTokenResponseClient() {
    DefaultAuthorizationCodeTokenResponseClient client = new DefaultAuthorizationCodeTokenResponseClient();

    RestTemplate restTemplate = new RestTemplate(Arrays.asList(
            new FormHttpMessageConverter(),
            new OAuth2AccessTokenResponseHttpMessageConverter()
    ));

    // Add custom interceptor to pass client_id and client_secret as form params (client_secret_post)
    restTemplate.setInterceptors(Collections.singletonList((request, body, execution) -> {
        if (request.getHeaders().getContentType() == MediaType.APPLICATION_FORM_URLENCODED) {
            // modify the request here if needed
        }
        return execution.execute(request, body);
    }));

    client.setRestOperations(restTemplate);
    return client;
}
```

---

### üí° Notes:

- Spring Security uses **client_secret_basic** by default (which sends the client credentials via HTTP Basic Auth header).
- `client_secret_post` puts `client_id` and `client_secret` in the **body** of the token request.
- If your provider expects `client_secret_post`, this override is necessary to ensure correct token exchange behavior.

---

Let me know if you want a **full working repo**, or if you're using `WebClient`/`RestTemplate` manually instead of `oauth2Login`.

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated()
            )
            .oauth2Login(oauth2 -> oauth2
                .tokenEndpoint(token -> token
                    .accessTokenResponseClient(postAuthCodeTokenResponseClient())
                )
            );

        return http.build();
    }

    private OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> postAuthCodeTokenResponseClient() {
        DefaultAuthorizationCodeTokenResponseClient client = new DefaultAuthorizationCodeTokenResponseClient();

        // Set a custom request entity converter to use POST with form params
        client.setRequestEntityConverter(new PostClientAuthRequestEntityConverter());

        return client;
    }

    static class PostClientAuthRequestEntityConverter implements Converter<OAuth2AuthorizationCodeGrantRequest, RequestEntity<?>> {
        private final OAuth2AuthorizationCodeGrantRequestEntityConverter defaultConverter = new OAuth2AuthorizationCodeGrantRequestEntityConverter();

        @Override
        public RequestEntity<?> convert(OAuth2AuthorizationCodeGrantRequest request) {
            RequestEntity<?> entity = defaultConverter.convert(request);

            // Replace the Authorization header with client_id and client_secret in the body
            MultiValueMap<String, String> formParams = new LinkedMultiValueMap<>();
            formParams.set("grant_type", "authorization_code");
            formParams.set("code", request.getAuthorizationExchange().getAuthorizationResponse().getCode());
            formParams.set("redirect_uri", request.getAuthorizationExchange().getAuthorizationRequest().getRedirectUri());
            formParams.set("client_id", request.getClientRegistration().getClientId());
            formParams.set("client_secret", request.getClientRegistration().getClientSecret());

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

            URI uri = entity.getUrl();

            return new RequestEntity<>(formParams, headers, HttpMethod.POST, uri);
        }
    }
}


package com.example.demo.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.*;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.client.endpoint.DefaultAuthorizationCodeTokenResponseClient;
import org.springframework.security.oauth2.client.endpoint.OAuth2AccessTokenResponseClient;
import org.springframework.security.oauth2.client.endpoint.OAuth2AuthorizationCodeGrantRequest;
import org.springframework.security.oauth2.client.endpoint.OAuth2AuthorizationCodeGrantRequestEntityConverter;
import org.springframework.security.oauth2.client.web.OAuth2LoginAuthenticationFilter;
import org.springframework.security.oauth2.core.endpoint.OAuth2ParameterNames;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RequestEntity;
import org.springframework.core.convert.converter.Converter;

import java.net.URI;

@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            )
            .oauth2Login(oauth2 -> oauth2
                .tokenEndpoint(token -> token
                    .accessTokenResponseClient(postAuthCodeTokenResponseClient())
                )
            );

        return http.build();
    }

    // Custom token response client to send client credentials via POST body
    private OAuth2AccessTokenResponseClient<OAuth2AuthorizationCodeGrantRequest> postAuthCodeTokenResponseClient() {
        DefaultAuthorizationCodeTokenResponseClient client = new DefaultAuthorizationCodeTokenResponseClient();
        client.setRequestEntityConverter(new PostClientAuthRequestEntityConverter());
        return client;
    }

    // Converter to override client authentication method (POST instead of Basic Auth)
    static class PostClientAuthRequestEntityConverter implements Converter<OAuth2AuthorizationCodeGrantRequest, RequestEntity<?>> {
        private final OAuth2AuthorizationCodeGrantRequestEntityConverter defaultConverter = new OAuth2AuthorizationCodeGrantRequestEntityConverter();

        @Override
        public RequestEntity<?> convert(OAuth2AuthorizationCodeGrantRequest request) {
            // Convert using default to get URI
            RequestEntity<?> defaultEntity = defaultConverter.convert(request);
            URI uri = defaultEntity.getUrl();

            // Build new body with client_id and client_secret
            MultiValueMap<String, String> formParams = new LinkedMultiValueMap<>();
            formParams.add(OAuth2ParameterNames.GRANT_TYPE, request.getGrantType().getValue());
            formParams.add(OAuth2ParameterNames.CODE, request.getAuthorizationExchange().getAuthorizationResponse().getCode());
            formParams.add(OAuth2ParameterNames.REDIRECT_URI, request.getAuthorizationExchange().getAuthorizationRequest().getRedirectUri());
            formParams.add(OAuth2ParameterNames.CLIENT_ID, request.getClientRegistration().getClientId());
            formParams.add(OAuth2ParameterNames.CLIENT_SECRET, request.getClientRegistration().getClientSecret());

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

            return new RequestEntity<>(formParams, headers, HttpMethod.POST, uri);
        }
    }
}


üîÑ To scan a folder of JARs:
powershell
Copy
Edit
foreach ($jar in Get-ChildItem -Filter *.jar -Recurse) {
    Write-Host "Checking $($jar.Name)..."
    jdeps -v $jar.FullName | findstr javax.servlet
}
This will show which JARs import or depend on javax.servlet.

‚úÖ Option 2: Using findstr + jar (without jdeps)
If jdeps is not available, you can unzip JARs and scan their contents:

üü¶ PowerShell script:
powershell
Copy
Edit
foreach ($jar in Get-ChildItem -Filter *.jar -Recurse) {
    $output = jar tf $jar.FullName | findstr "javax/servlet"
    if ($output) {
        Write-Host "$($jar.Name) uses javax.servlet"
    }
}
This checks if the javax.servlet package is referenced in class names.
----------
To disable a **Filter that comes from a dependency (not your own code)** in a **Spring Boot** application, there are several approaches depending on how the filter is registered. Here are your options:

---

## ‚úÖ 1. Disable by **FilterRegistrationBean**

If the filter is registered using `FilterRegistrationBean`, you can override it in your config and disable it:

```java
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FilterOverrideConfig {

    @Bean
    public FilterRegistrationBean<?> disableThirdPartyFilter() {
        FilterRegistrationBean<?> registration = new FilterRegistrationBean<>();
        registration.setFilter(new DummyFilter()); // placeholder, won't be used
        registration.setEnabled(false);            // this disables it
        registration.setName("filterNameFromDependency"); // must match the real name
        return registration;
    }
}
```

> üîç **Important**: You must know the **filter name** as registered by the dependency. You can find it in logs or decompile the dependency JAR to look at the `@WebFilter` or `FilterRegistrationBean`.

---

## ‚úÖ 2. Use `spring.autoconfigure.exclude` (for AutoConfig filters)

If the filter is auto-configured by Spring Boot via some `@Configuration`, you can exclude the auto-configuration class:

```yaml
spring:
  autoconfigure:
    exclude: com.example.dependency.SomeFilterAutoConfiguration
```

Or in code:

```java
@SpringBootApplication(exclude = SomeFilterAutoConfiguration.class)
public class MyApp {}
```

You‚Äôll need to identify the **exact auto-config class**. Use `spring-boot-actuator` or enable `debug=true` to inspect it.

---

## ‚úÖ 3. Disable by ServletContext `filterRegistration.setEnabled(false)` (advanced)

If you want to manually remove or disable a filter **after it's been registered**, you can write a `ServletContextInitializer`:

```java
@Bean
public ServletContextInitializer disableFilterProgrammatically() {
    return servletContext -> {
        FilterRegistration filterReg = servletContext.getFilterRegistration("filterName");
        if (filterReg != null) {
            // No direct disable API, but you could remove or override
        }
    };
}
```

‚ö†Ô∏è This method is tricky ‚Äî Spring Boot doesn't expose a clean disable API here unless you control the filter registration.

---

## ‚úÖ 4. Use Conditional Filter in Your Own Code (if you extend it)

If you can override or extend the 3rd party filter class, override `shouldNotFilter()` or wrap it conditionally:

```java
@Override
protected boolean shouldNotFilter(HttpServletRequest request) {
    return true; // disable this filter
}
```

---

## üîç How to Find the Filter Name?

Use this in a test config or `CommandLineRunner`:

```java
@Bean
public CommandLineRunner showRegisteredFilters(Filter[] filters) {
    return args -> {
        System.out.println("Registered filters:");
        for (Filter filter : filters) {
            System.out.println(" - " + filter.getClass().getName());
        }
    };
}
```

Or enable detailed logs:

```yaml
logging:
  level:
    org.springframework.boot.web.servlet: DEBUG
```

---

Would you like to share the filter class name or its package? I can help you write the exact code to disable it.
