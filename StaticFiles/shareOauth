# Central Authorization Server with Token Forwarding Example

Here's a comprehensive example of implementing Option 2, where you have a central authorization service that handles OAuth2 flows and forwards tokens to client applications.

## Architecture Overview

1. **Central Auth Service**: Handles OAuth2 login with providers
2. **Client Applications**: Redirect to central auth service, receive tokens
3. **Token Forwarding**: Auth service forwards tokens to clients after authentication

## 1. Central Authorization Service Implementation

### Dependencies (pom.xml)
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-client</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
</dependencies>
```

### Application Configuration
```java
@SpringBootApplication
public class AuthServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthServiceApplication.class, args);
    }
}
```

### Security Configuration
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/", "/login**", "/oauth2/**").permitAll()
                .anyRequest().authenticated()
            .and()
            .oauth2Login()
                .authorizationEndpoint()
                    .baseUri("/oauth2/authorize")
                    .authorizationRequestRepository(cookieAuthorizationRequestRepository())
                .and()
                .redirectionEndpoint()
                    .baseUri("/oauth2/callback/*")
                .and()
                .successHandler(oAuth2SuccessHandler());
    }

    @Bean
    public OAuth2SuccessHandler oAuth2SuccessHandler() {
        return new OAuth2SuccessHandler();
    }

    @Bean
    public AuthorizationRequestRepository<OAuth2AuthorizationRequest> cookieAuthorizationRequestRepository() {
        return new HttpCookieOAuth2AuthorizationRequestRepository();
    }
}
```

### OAuth2 Success Handler (Token Forwarding)
```java
@Component
public class OAuth2SuccessHandler extends SimpleUrlAuthenticationSuccessHandler {

    @Value("${allowed.redirect.domains}")
    private List<String> allowedRedirectDomains;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, 
                                       HttpServletResponse response, 
                                       Authentication authentication) throws IOException {
        
        String targetUrl = determineTargetUrl(request, authentication);
        
        if (response.isCommitted()) {
            logger.debug("Response has already been committed. Unable to redirect to " + targetUrl);
            return;
        }
        
        // Forward tokens to the client application
        String redirectUrl = request.getParameter("redirect_uri");
        if (isAllowedRedirect(redirectUrl)) {
            OAuth2AuthenticationToken authToken = (OAuth2AuthenticationToken) authentication;
            OAuth2AuthorizedClient client = authorizedClientService.loadAuthorizedClient(
                authToken.getAuthorizedClientRegistrationId(), 
                authToken.getName());
            
            String tokenForwardUrl = buildTokenForwardUrl(redirectUrl, client);
            getRedirectStrategy().sendRedirect(request, response, tokenForwardUrl);
        } else {
            throw new IllegalStateException("Invalid redirect URL");
        }
    }

    private String buildTokenForwardUrl(String baseUrl, OAuth2AuthorizedClient client) {
        UriComponentsBuilder builder = UriComponentsBuilder.fromUriString(baseUrl)
            .queryParam("access_token", client.getAccessToken().getTokenValue());
            
        if (client.getRefreshToken() != null) {
            builder.queryParam("refresh_token", client.getRefreshToken().getTokenValue());
        }
        
        return builder.build().toUriString();
    }

    private boolean isAllowedRedirect(String url) {
        if (url == null) return false;
        
        try {
            URI uri = new URI(url);
            String host = uri.getHost();
            return allowedRedirectDomains.stream().anyMatch(domain -> host.endsWith(domain));
        } catch (URISyntaxException e) {
            return false;
        }
    }
}
```

## 2. Client Application Implementation

### Client Security Configuration
```java
@Configuration
@EnableWebSecurity
public class ClientSecurityConfig extends WebSecurityConfigurerAdapter {

    @Value("${auth.service.url}")
    private String authServiceUrl;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/", "/login**", "/auth/callback").permitAll()
                .anyRequest().authenticated()
            .and()
            .oauth2Client()
            .and()
            .addFilterBefore(new TokenValidationFilter(), BasicAuthenticationFilter.class);
    }

    @Bean
    public OAuth2AuthorizedClientService authorizedClientService() {
        return new InMemoryOAuth2AuthorizedClientService();
    }

    @Bean
    public WebClient webClient(OAuth2AuthorizedClientService clientService) {
        ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2 = 
            new ServletOAuth2AuthorizedClientExchangeFilterFunction(clientService);
        return WebClient.builder()
            .apply(oauth2.oauth2Configuration())
            .build();
    }
}
```

### Token Validation Filter
```java
public class TokenValidationFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        if (request.getRequestURI().startsWith("/auth/callback")) {
            String accessToken = request.getParameter("access_token");
            // Validate token (could call auth service or validate locally)
            if (isValidToken(accessToken)) {
                // Store token in session or security context
                SecurityContextHolder.getContext().setAuthentication(
                    new PreAuthenticatedAuthenticationToken(accessToken, null));
            } else {
                response.sendError(HttpStatus.UNAUTHORIZED.value());
                return;
            }
        }
        
        filterChain.doFilter(request, response);
    }

    private boolean isValidToken(String token) {
        // Implement token validation logic
        return token != null && !token.isEmpty();
    }
}
```

## 3. Flow Explanation

1. **Client initiates login**:
   ```html
   <a href="https://auth-service.example.com/oauth2/authorize/google?redirect_uri=https://client1.example.com/auth/callback">
     Login with Google
   </a>
   ```

2. **Auth service handles OAuth2 flow** with the provider (Google in this case)

3. **After successful authentication**, the auth service:
   - Receives tokens from the provider
   - Validates and processes them
   - Redirects back to the client with tokens in URL parameters

4. **Client application**:
   - Receives tokens at the callback endpoint
   - Validates them (either locally or by calling auth service)
   - Establishes a session

## 4. Additional Considerations

### Token Security
- Use PKCE (Proof Key for Code Exchange) for public clients
- Consider using short-lived access tokens with refresh tokens
- Implement proper token validation in the client

### Configuration
```yaml
# Auth service application.yml
allowed:
  redirect:
    domains:
      - example.com
      - client1.com
      - client2.org

# Client application.yml
auth:
  service:
    url: https://auth-service.example.com
```

### Cross-Origin Considerations
If your clients are SPAs, you might need to:
- Use postMessage instead of redirects for token forwarding
- Implement proper CORS configuration
- Consider the OAuth2 implicit flow (though not recommended for new apps)

This architecture provides a centralized way to manage authentication while allowing multiple client applications to benefit from a single OAuth2 registration with providers.


---open AI

Yes! Here's a complete outline and code sample for **Option 2: Central OAuth2 Proxy Gateway**, where only **one app handles the OAuth2 login** (like `auth.example.com`) and **forwards the token/session** to multiple other client apps (`site1.example.com`, `site2.example.com`).

---

## üéØ Scenario

- You have a **central login server**: `auth.example.com`
- Multiple frontend web clients: `site1.example.com`, `site2.example.com`
- Only `auth.example.com` handles the OAuth2 login flow
- After login, it issues a **signed JWT** or session token
- Client apps **receive and validate the token**

---

## üõ†Ô∏è Components

### ‚úÖ `auth.example.com` (Spring Boot app)
- Has OAuth2 login (e.g., Google, Okta, custom)
- After login, issues JWT token and **redirects with token or sets shared cookie**

### ‚úÖ `site1.example.com`, `site2.example.com` (Spring Boot clients)
- No OAuth2 login config
- Read and validate JWT token (via cookie or redirect param)
- Authenticated locally using token

---

## üîí JWT Token Sharing ‚Äì Approaches
- **üîÅ Redirect + Token Param:** Send JWT as a URL parameter on redirect (`?token=...`)
- **üç™ Cookie-based:** Set a shared cookie (`Domain=.example.com`)
- **üì¶ Header forwarding:** For internal APIs or AJAX use

We‚Äôll demo both **redirect + token param** and **cookie** below.

---

## üîß 1. `auth.example.com` Configuration

### `application.yml`:

```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: YOUR_CLIENT_ID
            client-secret: YOUR_CLIENT_SECRET
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
            scope: openid, profile, email
        provider:
          google:
            authorization-uri: https://accounts.google.com/o/oauth2/v2/auth
            token-uri: https://oauth2.googleapis.com/token
            user-info-uri: https://www.googleapis.com/oauth2/v3/userinfo
            user-name-attribute: sub
```

---

### Custom Success Handler

```java
@Component
public class OAuth2LoginSuccessHandler extends SimpleUrlAuthenticationSuccessHandler {

    private final JwtService jwtService;

    public OAuth2LoginSuccessHandler(JwtService jwtService) {
        this.jwtService = jwtService;
    }

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request,
                                        HttpServletResponse response,
                                        Authentication authentication)
            throws IOException, ServletException {

        String jwt = jwtService.generateToken(authentication);

        // Option 1: Send via redirect param
        String target = request.getParameter("redirect_uri"); // passed in login request
        if (target != null && !target.isBlank()) {
            getRedirectStrategy().sendRedirect(request, response, target + "?token=" + jwt);
        } else {
            response.getWriter().write("Login success, no redirect_uri specified.");
        }
    }
}
```

---

### Security Config

```java
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain security(HttpSecurity http, OAuth2LoginSuccessHandler successHandler) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
            .oauth2Login(oauth -> oauth.successHandler(successHandler));
        return http.build();
    }
}
```

---

### JWT Service (same as Option 3)

```java
@Component
public class JwtService {
    private final Key key = Keys.secretKeyFor(SignatureAlgorithm.HS256);

    public String generateToken(Authentication auth) {
        return Jwts.builder()
                .setSubject(auth.getName())
                .claim("authorities", auth.getAuthorities())
                .setIssuedAt(new Date())
                .setExpiration(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))
                .signWith(key)
                .compact();
    }

    public Authentication parseToken(String token) {
        try {
            Claims claims = Jwts.parserBuilder().setSigningKey(key).build()
                    .parseClaimsJws(token).getBody();
            String username = claims.getSubject();
            List<GrantedAuthority> authorities = ((List<?>) claims.get("authorities")).stream()
                    .map(auth -> new SimpleGrantedAuthority(auth.toString()))
                    .toList();
            return new UsernamePasswordAuthenticationToken(username, null, authorities);
        } catch (Exception e) {
            return null;
        }
    }
}
```

---

## üîß 2. `site1.example.com` ‚Äì Trust JWT from Gateway

This app has no OAuth2 config ‚Äî it just **accepts the JWT token** (from query param or cookie) and authenticates users.

### JWT Auth Filter

```java
@Component
public class JwtAuthFilter extends OncePerRequestFilter {

    @Autowired
    JwtService jwtService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        String token = request.getParameter("token"); // or from cookie/header

        if (token != null) {
            Authentication auth = jwtService.parseToken(token);
            if (auth != null) {
                SecurityContextHolder.getContext().setAuthentication(auth);
            }
        }

        filterChain.doFilter(request, response);
    }
}
```

---

### Security Config for `site1`

```java
@Configuration
public class SecurityConfig {

    @Autowired
    JwtAuthFilter jwtAuthFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf().disable()
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .anyRequest().authenticated())
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
```

---

### üí° Redirect Example Flow

1. User goes to `site1.example.com/dashboard`
2. If not authenticated, redirect to:
   ```
   https://auth.example.com/oauth2/authorization/google?redirect_uri=https://site1.example.com/auth/callback
   ```
3. After login, Spring redirects to:
   ```
   https://site1.example.com/auth/callback?token=eyJhbGciOiJI...
   ```
4. `site1` reads token from param, authenticates the user

---

## ‚úÖ Optional: Token Relay via Cookie

If you're using shared subdomains (e.g., `.example.com`), you can **set a shared cookie** from `auth.example.com`, and the clients (`site1`, `site2`) can read it like in Option 3.

Use:

```java
ResponseCookie cookie = ResponseCookie.from("AUTH_TOKEN", jwt)
    .domain(".example.com")
    .path("/")
    .secure(true)
    .httpOnly(true)
    .sameSite("Lax")
    .build();
response.addHeader(HttpHeaders.SET_COOKIE, cookie.toString());
```

Then the clients just pull the token from `request.getCookies()` instead of `request.getParameter("token")`.

---

Would you like a working GitHub sample or starter project for this?

-----------------------------------openAI2
Yes! Here‚Äôs a simple **Spring Boot-based implementation** of **Option 1: SSO via OAuth2 Proxy Login**, where:

- **Site1** redirects to **Auth Site** to initiate login.
- **Auth Site** authenticates with the OAuth server (`wam.company.com`).
- After successful login, **Auth Site redirects back to Site1** with a **signed JWT**.
- **Site1 verifies the token** and creates a local session.

---

### üîß Assumptions
- You‚Äôre using **Spring Boot + Spring Security + OAuth2 Client**.
- **JWT** is used as the token format between Auth Site and Site1.
- A **shared secret** or **public key infrastructure** exists between Site1 and Auth Site.

---

## ‚úÖ 1. **Auth Site** ‚Äî Initiate OAuth2 Login & Return Token

### `application.yml` (OAuth2 Client Setup)
```yaml
spring:
  security:
    oauth2:
      client:
        registration:
          wam:
            client-id: your-client-id
            client-secret: your-secret
            scope: openid, profile, email
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
            authorization-grant-type: authorization_code
            client-name: WAM
        provider:
          wam:
            issuer-uri: https://wam.company.com
```

### Auth Controller ‚Äî `/loginProxy`
```java
@RestController
@RequestMapping("/proxy")
public class ProxyLoginController {

    @GetMapping("/login")
    public ResponseEntity<Void> proxyLogin(HttpServletRequest request) {
        String redirectUri = request.getParameter("redirect_uri");
        request.getSession().setAttribute("redirect_uri", redirectUri);
        URI uri = URI.create("/oauth2/authorization/wam"); // this triggers Spring Security's login
        HttpHeaders headers = new HttpHeaders();
        headers.setLocation(uri);
        return new ResponseEntity<>(headers, HttpStatus.FOUND);
    }

    @GetMapping("/callback")
    public ResponseEntity<Void> handleCallback(Authentication authentication, HttpServletRequest request) {
        OidcUser oidcUser = (OidcUser) authentication.getPrincipal();
        
        // Generate signed JWT (can use Nimbus JOSE + JWT or jjwt)
        String jwt = JwtUtils.generateToken(oidcUser); // implement this

        String redirectUri = (String) request.getSession().getAttribute("redirect_uri");
        URI uri = URI.create(redirectUri + "?token=" + jwt);

        HttpHeaders headers = new HttpHeaders();
        headers.setLocation(uri);
        return new ResponseEntity<>(headers, HttpStatus.FOUND);
    }
}
```

> üîê **Token Generation** can use `io.jsonwebtoken` or `nimbus-jose-jwt`.

---

## ‚úÖ 2. **Site1** ‚Äî Accept Token & Authenticate Locally

### `application.yml`
No need for OAuth2 config unless you plan to directly integrate with `wam.company.com`.

### `TokenAuthenticationFilter.java`
```java
public class TokenAuthenticationFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
        throws ServletException, IOException {

        String token = request.getParameter("token");
        if (token != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            try {
                Claims claims = JwtUtils.parseToken(token); // validate signature, expiry, etc.
                String username = claims.getSubject();

                List<GrantedAuthority> authorities = List.of(new SimpleGrantedAuthority("ROLE_USER"));
                UsernamePasswordAuthenticationToken auth =
                        new UsernamePasswordAuthenticationToken(username, null, authorities);
                SecurityContextHolder.getContext().setAuthentication(auth);
            } catch (JwtException e) {
                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                return;
            }
        }
        filterChain.doFilter(request, response);
    }
}
```

### Register Filter
```java
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .addFilterBefore(new TokenAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            );
        return http.build();
    }
}
```

---

## ‚úÖ 3. **JWT Utility (Shared by Both Apps)**

### `JwtUtils.java`
```java
public class JwtUtils {
    private static final String SECRET = "your-shared-secret"; // Store securely

    public static String generateToken(OidcUser user) {
        return Jwts.builder()
                .setSubject(user.getEmail())
                .claim("name", user.getFullName())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + 5 * 60 * 1000))
                .signWith(SignatureAlgorithm.HS256, SECRET)
                .compact();
    }

    public static Claims parseToken(String token) {
        return Jwts.parser()
                .setSigningKey(SECRET)
                .parseClaimsJws(token)
                .getBody();
    }
}
```

---

### üß™ Flow Test Summary

| Step | Action |
|------|--------|
| 1 | Site1 redirects to `https://clientappt.company.com/proxy/login?redirect_uri=https://site1.clientappt.company.com/callback` |
| 2 | Auth Site authenticates via WAM |
| 3 | Auth Site generates JWT and redirects back to Site1 with token |
| 4 | Site1 reads token, verifies it, logs in user |

---

Want me to package this into two minimal Spring Boot starter projects (`site1` and `auth-site`) for local testing?



Yes ‚Äî if you‚Äôre using a **self-signed SSL certificate** and getting SSL errors with `RestTemplate`, you can configure a custom `RestTemplate` bean that **trusts self-signed certificates**.

Here‚Äôs a clean solution using a custom class that builds a `RestTemplate` that **ignores SSL certificate errors**. This is often used **in dev/test environments** ‚Äî never use this in production unless you explicitly manage security.

---

### ‚úÖ Custom `RestTemplate` that Trusts Self-Signed SSL

```java
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

import javax.net.ssl.*;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;

import org.apache.http.conn.ssl.NoopHostnameVerifier;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

public class UnsafeRestTemplateFactory {

    public static RestTemplate create() throws Exception {
        // Trust manager that ignores certificate validation
        TrustManager[] trustAllCerts = new TrustManager[]{
            new X509TrustManager() {
                public void checkClientTrusted(X509Certificate[] xcs, String string) {}
                public void checkServerTrusted(X509Certificate[] xcs, String string) {}
                public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }
            }
        };

        // Set up SSL context
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(null, trustAllCerts, new SecureRandom());

        // Create socket factory with Noop HostnameVerifier to ignore hostname mismatch
        SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory(
                sslContext, NoopHostnameVerifier.INSTANCE);

        CloseableHttpClient httpClient = HttpClients.custom()
                .setSSLSocketFactory(socketFactory)
                .build();

        HttpComponentsClientHttpRequestFactory factory =
                new HttpComponentsClientHttpRequestFactory(httpClient);

        return new RestTemplate(factory);
    }
}
```

---

### üß™ Example Usage

```java
@RestController
public class TestController {

    @GetMapping("/test-ssl")
    public String testSSL() throws Exception {
        RestTemplate restTemplate = UnsafeRestTemplateFactory.create();
        String response = restTemplate.getForObject("https://your-self-signed-site.local", String.class);
        return response;
    }
}
```

---

### ‚ö†Ô∏è Important Notes

- This completely **disables SSL certificate validation and hostname verification**. Only use this in:
  - **Internal tools**
  - **Local development**
  - **Testing against mock services**
- If you're in **production**, it's better to:
  - Import your self-signed cert into a truststore.
  - Configure SSL context with proper keystore/truststore.

---

Would you like a version that loads a **custom truststore with your self-signed cert** instead (safer than fully skipping checks)?


Yes ‚Äî in **Spring Boot**, you can **conditionally apply filters** based on URL patterns using one of the following approaches:

---

## ‚úÖ Option 1: Configure Filters Manually via `FilterRegistrationBean`

This gives you full control over which URLs each filter applies to.

### Example Setup:

```java
@Configuration
public class FilterConfig {

    @Bean
    public FilterRegistrationBean<LoadingUserFilter> userFilter() {
        FilterRegistrationBean<LoadingUserFilter> registrationBean = new FilterRegistrationBean<>();
        registrationBean.setFilter(new LoadingUserFilter());
        registrationBean.addUrlPatterns("/secure/*"); // Not applied to /public
        registrationBean.setOrder(1);
        return registrationBean;
    }

    @Bean
    public FilterRegistrationBean<CheckingAddressFilter> addressFilter() {
        FilterRegistrationBean<CheckingAddressFilter> registrationBean = new FilterRegistrationBean<>();
        registrationBean.setFilter(new CheckingAddressFilter());
        registrationBean.addUrlPatterns("/secure/*", "/office/*");
        registrationBean.setOrder(2);
        return registrationBean;
    }

    @Bean
    public FilterRegistrationBean<OfficeFunctionFilter> officeFilter() {
        FilterRegistrationBean<OfficeFunctionFilter> registrationBean = new FilterRegistrationBean<>();
        registrationBean.setFilter(new OfficeFunctionFilter());
        registrationBean.addUrlPatterns("/office/*"); // Only applies to office
        registrationBean.setOrder(3);
        return registrationBean;
    }
}
```

---

## ‚úÖ Option 2: Inside the Filter Itself (Path-Based Logic)

If you want to register a filter globally but have internal logic to skip paths:

```java
public class LoadingUserFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
        throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;
        String path = req.getRequestURI();

        if (path.startsWith("/public")) {
            chain.doFilter(request, response); // Skip filter
            return;
        }

        // Execute filter logic
        // ...
        chain.doFilter(request, response);
    }
}
```

---

## ‚úÖ Option 3: Use `OncePerRequestFilter` + `AntPathMatcher` for More Complex Rules

```java
public class ConditionalFilter extends OncePerRequestFilter {
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
        throws ServletException, IOException {

        String path = request.getRequestURI();
        if (pathMatcher.match("/public/**", path)) {
            filterChain.doFilter(request, response); // skip
            return;
        }

        // Otherwise do the filter logic
        filterChain.doFilter(request, response);
    }
}
```

---

### Summary of What You Asked:

| URL Path        | Filters Applied                     |
|----------------|--------------------------------------|
| `/public/**`    | ‚ùå `LoadingUserFilter`, `CheckingAddressFilter` |
| `/office/**`    | ‚úÖ `OfficeFunctionFilter`           |
| `/secure/**`    | ‚úÖ All relevant filters             |

Use `FilterRegistrationBean` if you want the cleanest and most declarative control.

Let me know if you'd like me to generate a full sample Spring Boot class set for your filters.
