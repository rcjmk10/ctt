Thank you! Based on your clarified request, you're asking me to **rewrite the method using Option 1**, meaning:

> âœ… Use the **MSAL Java `ConfidentialClientApplication`** with private key + certificate to acquire the access token manually,
> âœ… Configure the Graph client with the **proxy**,
> âœ… Avoid `ClientCertificateCredentialBuilder`, and instead **construct the token yourself**.

Hereâ€™s the **rewritten version of your `initGraphClient()`** method using **Option 1**:

---

### âœ… Rewritten `initGraphClient()` Using Manual Token Flow via MSAL

```java
private GraphServiceClient<?> initGraphClient() throws Exception {

    // 1. Setup proxy for both MSAL and Graph client
    final InetSocketAddress proxyAddress = new InetSocketAddress(proxyHost, proxyPort);
    final Proxy graphProxy = new Proxy(Proxy.Type.HTTP, proxyAddress);

    // 2. Parse private key and certificate from base64-encoded keystore or PEM
    PrivateKey privateKey = loadPrivateKeyFromPem();        // <-- You must implement this
    X509Certificate certificate = loadCertificateFromPem(); // <-- You must implement this

    // 3. Build the confidential client (manual token flow)
    ConfidentialClientApplication app = ConfidentialClientApplication.builder(
            outlook_client_id,
            ClientCredentialFactory.createFromCertificate(privateKey, certificate))
            .authority("https://login.microsoftonline.com/" + outlook_tenant_id)
            .build();

    // 4. Acquire access token manually using client credentials
    ClientCredentialParameters parameters = ClientCredentialParameters.builder(
            Collections.singleton("https://graph.microsoft.com/.default"))
            .build();

    IAuthenticationResult result = app.acquireToken(parameters).get();
    String token = result.accessToken();

    log.error("******************************************************************************************\n" +
            "ClientID: " + outlook_client_id + ", tenantId: " + outlook_tenant_id + ", token: " + token);

    // 5. Use a custom auth provider with the token
    TokenCredentialAuthProvider authProvider = new TokenCredentialAuthProvider(
            SCOPES,
            request -> Mono.just(new AccessToken(token, OffsetDateTime.now().plusHours(1)))
    );

    // 6. Build OkHttp client with proxy
    OkHttpClient okClient = HttpClients.createDefault(authProvider)
            .newBuilder()
            .proxy(graphProxy)
            .build();

    // 7. Return Graph client
    return GraphServiceClient
            .builder()
            .authenticationProvider(authProvider)
            .httpClient(okClient)
            .buildClient();
}
```

---

### ðŸ§© Helper Notes

You need to implement these two helpers:

#### `loadPrivateKeyFromPem()`

If you're using a Base64 PEM-encoded key (PKCS#8), use:

```java
private PrivateKey loadPrivateKeyFromPem() throws Exception {
    byte[] keyBytes = Base64.getDecoder().decode(encodedPrivateKey);
    PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
    KeyFactory kf = KeyFactory.getInstance("RSA");
    return kf.generatePrivate(spec);
}
```

#### `loadCertificateFromPem()`

If you're using a Base64 X.509 certificate:

```java
private X509Certificate loadCertificateFromPem() throws Exception {
    byte[] certBytes = Base64.getDecoder().decode(encodedCert);
    CertificateFactory cf = CertificateFactory.getInstance("X.509");
    return (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(certBytes));
}
```

Let me know if your cert is stored in a `.pfx`/`.p12` file or a PKCS12 keystore â€” I can adjust these loaders accordingly.

---

Would you like me to help build a loader from `.pfx` (PKCS12) with password instead?
