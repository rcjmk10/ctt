private GraphServiceClient<?> initGraphClient() throws Exception {
    // 1. Setup proxy
    final InetSocketAddress proxyAddress = new InetSocketAddress(proxyHost, proxyPort);
    final Proxy graphProxy = new Proxy(Proxy.Type.HTTP, proxyAddress);

    // 2. Decode the Base64-encoded PFX content
    byte[] pfxBytes = Base64.getDecoder().decode(encodedCertificate);

    // 3. Load PKCS12 keystore
    KeyStore keystore = KeyStore.getInstance("PKCS12");
    keystore.load(new ByteArrayInputStream(pfxBytes), "changeit".toCharArray());  // changeit = password

    String alias = null;
    Enumeration<String> aliases = keystore.aliases();
    if (aliases.hasMoreElements()) {
        alias = aliases.nextElement();
    } else {
        throw new Exception("No alias found in the keystore");
    }

    // 4. Extract private key and certificate
    PrivateKey privateKey = (PrivateKey) keystore.getKey(alias, "changeit".toCharArray());
    X509Certificate certificate = (X509Certificate) keystore.getCertificate(alias);

    if (privateKey == null || certificate == null) {
        throw new Exception("Failed to extract private key or certificate from keystore");
    }

    // 5. Initialize MSAL confidential client
    ConfidentialClientApplication app = ConfidentialClientApplication.builder(
            outlook_client_id,
            ClientCredentialFactory.createFromCertificate(privateKey, certificate))
            .authority("https://login.microsoftonline.com/" + outlook_tenant_id)
            .build();

    // 6. Acquire token manually
    ClientCredentialParameters parameters = ClientCredentialParameters.builder(
            Collections.singleton("https://graph.microsoft.com/.default"))
            .build();

    IAuthenticationResult result = app.acquireToken(parameters).get();
    String token = result.accessToken();

    log.error("******************************************************************************************\n" +
            "ClientID: " + outlook_client_id + ", tenantId: " + outlook_tenant_id + ", token: " + token);

    // 7. Auth provider using manually-acquired token
    TokenCredentialAuthProvider authProvider = new TokenCredentialAuthProvider(
            SCOPES,
            request -> Mono.just(new AccessToken(token, OffsetDateTime.now().plusHours(1)))
    );

    // 8. Configure Graph client with proxy
    OkHttpClient okClient = HttpClients.createDefault(authProvider)
            .newBuilder()
            .proxy(graphProxy)
            .build();

    return GraphServiceClient
            .builder()
            .authenticationProvider(authProvider)
            .httpClient(okClient)
            .buildClient();
}





Here's your modified `initGraphClient()` method using **Option 3**, which:

1. **Manually builds a client assertion (JWT)**
2. **Signs it with your extracted private key**
3. **Uses OkHttp to call the Azure AD token endpoint**
4. **Injects the token into Microsoft Graph client**

---

### âœ… Modified `initGraphClient()` (Manual Token Request)

```java
private GraphServiceClient<?> initGraphClient() throws Exception {
    // 1. Setup proxy
    final InetSocketAddress proxyAddress = new InetSocketAddress(proxyHost, proxyPort);
    final Proxy graphProxy = new Proxy(Proxy.Type.HTTP, proxyAddress);

    // 2. Decode base64-encoded PFX
    byte[] pfxBytes = Base64.getDecoder().decode(encodedCertificate);
    KeyStore keystore = KeyStore.getInstance("PKCS12");
    keystore.load(new ByteArrayInputStream(pfxBytes), "changeit".toCharArray());

    String alias = keystore.aliases().nextElement();
    PrivateKey privateKey = (PrivateKey) keystore.getKey(alias, "changeit".toCharArray());
    X509Certificate certificate = (X509Certificate) keystore.getCertificate(alias);

    if (privateKey == null || certificate == null) {
        throw new Exception("Failed to extract private key or certificate from keystore");
    }

    // 3. Build JWT assertion for Azure AD
    String clientAssertion = buildClientAssertion(outlook_client_id, outlook_tenant_id, privateKey, certificate);

    // 4. Build token request with OkHttp
    OkHttpClient okHttpClient = new OkHttpClient.Builder().proxy(graphProxy).build();
    RequestBody body = new FormBody.Builder()
            .add("client_id", outlook_client_id)
            .add("scope", "https://graph.microsoft.com/.default")
            .add("client_assertion_type", "urn:ietf:params:oauth:client-assertion-type:jwt-bearer")
            .add("client_assertion", clientAssertion)
            .add("grant_type", "client_credentials")
            .build();

    Request request = new Request.Builder()
            .url("https://login.microsoftonline.com/" + outlook_tenant_id + "/oauth2/v2.0/token")
            .post(body)
            .build();

    try (Response response = okHttpClient.newCall(request).execute()) {
        if (!response.isSuccessful()) {
            throw new IOException("Token request failed: " + response.code() + " - " + response.body().string());
        }
        String json = response.body().string();
        String token = new JSONObject(json).getString("access_token");

        // 5. Inject token into Graph client
        TokenCredentialAuthProvider authProvider = new TokenCredentialAuthProvider(
                SCOPES,
                req -> Mono.just(new AccessToken(token, OffsetDateTime.now().plusHours(1)))
        );

        OkHttpClient okClient = HttpClients.createDefault(authProvider)
                .newBuilder()
                .proxy(graphProxy)
                .build();

        return GraphServiceClient.builder()
                .authenticationProvider(authProvider)
                .httpClient(okClient)
                .buildClient();
    }
}
```

---

### ðŸ”§ `buildClientAssertion(...)` Helper

```java
private String buildClientAssertion(String clientId, String tenantId,
                                    PrivateKey privateKey, X509Certificate certificate) throws Exception {

    long now = System.currentTimeMillis() / 1000L;
    JWTClaimsSet claimsSet = new JWTClaimsSet.Builder()
            .issuer(clientId)
            .subject(clientId)
            .audience("https://login.microsoftonline.com/" + tenantId + "/v2.0")
            .issueTime(new Date(now * 1000))
            .expirationTime(new Date((now + 600) * 1000)) // 10 mins
            .jwtID(UUID.randomUUID().toString())
            .build();

    JWSHeader header = new JWSHeader.Builder(JWSAlgorithm.RS256)
            .keyID(getKeyId(certificate))
            .type(JOSEObjectType.JWT)
            .build();

    SignedJWT signedJWT = new SignedJWT(header, claimsSet);
    signedJWT.sign(new RSASSASigner(privateKey));
    return signedJWT.serialize();
}

private String getKeyId(X509Certificate certificate) throws Exception {
    MessageDigest sha1 = MessageDigest.getInstance("SHA-1");
    byte[] thumbprint = sha1.digest(certificate.getEncoded());
    return Base64.getUrlEncoder().withoutPadding().encodeToString(thumbprint);
}
```

---

### ðŸ§© Dependencies (Maven)

```xml
<dependency>
    <groupId>com.nimbusds</groupId>
    <artifactId>nimbus-jose-jwt</artifactId>
    <version>9.37.3</version>
</dependency>
<dependency>
    <groupId>com.squareup.okhttp3</groupId>
    <artifactId>okhttp</artifactId>
    <version>4.12.0</version>
</dependency>
<dependency>
    <groupId>org.json</groupId>
    <artifactId>json</artifactId>
    <version>20231013</version>
</dependency>
```

---

Yes â€” hereâ€™s the **complete list of Java imports** needed for the manually signed JWT + OkHttp Microsoft Graph client setup:

---

### âœ… Imports for `initGraphClient()` and `buildClientAssertion(...)`

```java
// Java core
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.security.KeyFactory;
import java.security.KeyStore;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.interfaces.RSAPrivateKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.time.OffsetDateTime;
import java.util.Base64;
import java.util.Collections;
import java.util.Date;
import java.util.Enumeration;
import java.util.UUID;

// OkHttp
import okhttp3.FormBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

// JSON
import org.json.JSONObject;

// Microsoft Graph
import com.microsoft.graph.authentication.TokenCredentialAuthProvider;
import com.microsoft.graph.models.extensions.GraphServiceClient;
import com.microsoft.graph.requests.GraphServiceClient;
import com.azure.core.credential.AccessToken;
import reactor.core.publisher.Mono;

// Nimbus JOSE JWT
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JOSEObjectType;
import com.nimbusds.jose.crypto.RSASSASigner;
```

---

### ðŸ“¦ Maven Dependencies Summary

Ensure youâ€™ve added the following in your `pom.xml`:

```xml
<!-- JWT generation and signing -->
<dependency>
    <groupId>com.nimbusds</groupId>
    <artifactId>nimbus-jose-jwt</artifactId>
    <version>9.37.3</version>
</dependency>

<!-- Microsoft Graph SDK -->
<dependency>
    <groupId>com.microsoft.graph</groupId>
    <artifactId>microsoft-graph</artifactId>
    <version>5.65.0</version>
</dependency>

<!-- Azure Core for AccessToken (used in auth provider) -->
<dependency>
    <groupId>com.azure</groupId>
    <artifactId>azure-core</artifactId>
    <version>1.46.0</version>
</dependency>

<!-- OkHttp client -->
<dependency>
    <groupId>com.squareup.okhttp3</groupId>
    <artifactId>okhttp</artifactId>
    <version>4.12.0</version>
</dependency>

<!-- JSON for parsing token response -->
<dependency>
    <groupId>org.json</groupId>
    <artifactId>json</artifactId>
    <version>20231013</version>
</dependency>
```

---

Let me know if you're using Gradle or need help adapting this to Spring Boot config or async workflows.
459F2082C03D6A8225950899D9AD665E39088CC7
private String getKeyId(X509Certificate certificate) throws Exception {
    MessageDigest sha1 = MessageDigest.getInstance("SHA-1");
    byte[] thumbprint = sha1.digest(certificate.getEncoded());

    StringBuilder hexString = new StringBuilder();
    for (byte b : thumbprint) {
        hexString.append(String.format("%02X", b)); // UPPERCASE hex
    }
    return hexString.toString();
}
